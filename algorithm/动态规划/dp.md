# dp

> **_维基百科_**：动态规划在寻找有很多重叠子问题的情况的最佳解时有效。它将问题重新组合成子问题，为了避免多次解决这些子问题，它们的结果都逐渐被计算并被储存，从简单的问题直到整个问题都被解决。因此，动态规划储存递归时的结果，因而不会在解决同样的问题时花费时间。
>
> 动态规划只能应用于有最佳子结构的问题。最佳子结构的意思是局部最佳解能决定全域最佳解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。

### 主要思想：

- **将原问题分解成更简单的子问题**，通过子问题的最佳解来得到原问题的最佳解
- **记忆化搜索**，存储子问题的解，解决重叠子问题多次计算的问题

### 动态规划的三要素:

- 最优子结构：原问题最优解所包含的子问题都是最优的（子问题的最优解能组合成原问题的最优解）则该子问题为原问题的最优子结构。
- 状态转移方程：表示前后阶段关系的方程（原问题与子问题的关系方程）。
- 边界：无需继续分解，可以直接得到值的问题（没有边界的问题是无解的）。

### 动态规划题目特点：

- 计数
  - 有**多少种**方式走到右下角
  - 有**多少种**方法选出 k 个数使得和是 Sum
- 求最大最小值（极值）
  - 从左上角走到右下角路径的**最大**数字和
  - **最长**上升子序列长度
- 求存在性
  - 取石子游戏，先手**是否**必胜
  - **能不能**选出 k 个数使得和是 Sum

### 解题思路，四大步骤 👇

步骤一：_**确定状态**_

- 简单的说，解动态规划的时候需要开一个数组，数组的每个元素 `f[i]` 或者 `f[i][j]` 代表什么，类似于数学题中，X，Y，Z 代表什么
- 确定状态需要两个意识
  - 最后一步
  - 子问题

步骤二：_**列出状态转移方程**_

f[x] = min{ f[x-1] + 1, f[x-2] + 1}

将原问题转化成了一个子问题，而且规模更小了

步骤三：_**初始条件和边界情况**_

初始条件通常是类似 `f[0]=0`

> 初始条件是用转移方程算不出来的，需要手动定义，比如下面的硬币问题按照状态转移方程计算的 f[0]=正无穷，但是我们明明知道 f[0]=0，这是就需要我们手动定义了。

步骤四：_**确定计算顺序**_

当计算到 f[x] 时，f[x-1]，f[x-2] 都已经得到计算结果了。
一般线性的动态规划是从小到大，区间（二维）是从上到下，从左到右。

### 例题

#### 例题一 [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  `-1`。

你可以认为每种硬币的数量是无限的。

解题思路：

题目是求**最少**，联想到是否可以使用动态规划求解。

---

步骤一 确定状态

虽然我们不知道最优策略是什么，但是最优策略肯定是 k 枚硬币 a<sub>1</sub>,a<sub>2</sub>,...,a<sub>k</sub> 面值加起来等于总金额 amount

**最后一步：**

- 最优策略中使用的最后一枚硬币是 a<sub>k</sub>
- 除掉最后一枚硬币的总金额是 amount - a<sub>k</sub>

关键点一：

我们不关心前面的 k-1 枚硬币是怎么拼出 amount - a<sub>k</sub> 的，而且我们现在甚至还不知道 a<sub>k</sub> 和 k，但是我们确定前面的硬币拼出了 amount - a<sub>k</sub>

关键点二：

因为是最优策略，所以拼出 amount - a<sub>k</sub> 的硬币数一定要最少，否则这就不是最优策略了

**子问题**

所以要求凑成总金额 amount 所需的最少的硬币个数

- 原问题是最少用多少枚硬币拼出 amount
- 我们将原问题转化成了一个子问题，而且规模更小了：凑成总金额 amount - a<sub>k</sub> 所需的最少的硬币个数
- 为了简化定义，我们**设状态 `f[x]` 为最少用多少枚硬币拼出 x**

---

步骤二 列出状态转移方程

假设最后那枚硬币只可能是 2，5 或者 7

我们就可以列出方程：

```js
f[x] = min{ f[x-2]+1, f[x-5]+1, f[x-7]+1 }
```

此时我们也可以思考用递归解法

[递归解法](./线性/零钱兑换/1.js)

缺点

- 会有大量的重复计算
- 时间复杂度是指数级别的

> leetcode amount=100 的时候就已经执行超时了，可以使用备忘录优化

---

步骤三 初始条件和边界情况

两个问题：x-2,x-5 或者 x-7 小于 0 怎么办？什么时候停下来？

**边界情况：**
如果拼不出 x ,就定义 f[x] = Infinity
例如 f[-1]=f[-2]=...=Infinity

**初始条件：f[0] = 0**

---

步骤四 计算顺序

f[0], f[1], f[2], ...

从小到大，每一步尝试 `coins.length` 种硬币，一共 `amount` 步，没有任何重复计算

算法的时间复杂度（即需要进行的步数）：`amount * coins.length`

---

[零钱兑换代码实现—动态规划](./线性/零钱兑换/2.js)

[「算法与数据结构」一张脑图带你看动态规划算法之美](https://juejin.cn/post/6872115031501340679#heading-1)
